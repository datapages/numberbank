[
  {
    "objectID": "contributors.html",
    "href": "contributors.html",
    "title": "Contributors",
    "section": "",
    "text": "Lauren Oey\n\n\n\n\n\n\n\nRose Schneider\n\n\n\n\n\n\n\nDavid Barner\n\n\n\n\n\n\n\nMike Frank"
  },
  {
    "objectID": "contributors.html#the-numberbank-team",
    "href": "contributors.html#the-numberbank-team",
    "title": "Contributors",
    "section": "",
    "text": "Lauren Oey\n\n\n\n\n\n\n\nRose Schneider\n\n\n\n\n\n\n\nDavid Barner\n\n\n\n\n\n\n\nMike Frank"
  },
  {
    "objectID": "md/disclaimer-items.html",
    "href": "md/disclaimer-items.html",
    "title": "Numberbank",
    "section": "",
    "text": "Disclaimer text goes here"
  },
  {
    "objectID": "index.html#datasets-in-numberbank",
    "href": "index.html#datasets-in-numberbank",
    "title": "Numberbank",
    "section": "Datasets in Numberbank",
    "text": "Datasets in Numberbank\n\n\n\n\n\n\n\n\n\n\n\nThis material is based upon work supported by the National Science Foundation under Grant No. 221960. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the National Science Foundation."
  },
  {
    "objectID": "submit.html",
    "href": "submit.html",
    "title": "Submit Data",
    "section": "",
    "text": "Numberbank uses a tidy format for encoding data. In order to submit data, we suggest that you enter it in this format at the time of data collection, using the templates provided below. We will also accept data in other forms, if the data have already been collected and do not match this format. For each template, we have entered example data for two participants. Researchers can download these templates, erase example data, and enter their own.\nknower level template: data on individual subjects and their knower level\ntrial level template: data on subjects’ trial by trial responses when prompted to give N\nhighest count template: data on individual subjects and the highest number they can count up to"
  },
  {
    "objectID": "methods.html",
    "href": "methods.html",
    "title": "Methods",
    "section": "",
    "text": "While children begin to recite the count list at a very young age (usually by around 2 years; Fuson, 1988), it takes them several years to learn the meanings of the individual words in the count list. For instance, if you ask 2-year-old who can count up to 10 for a set of 3 items, they may give you a random handful. Initially, children can recite a rote count list, like the alphabet. This ability to recite the count list is often measured by the “Highest Count” task.\nInstead of learning the meanings of all these number words at once, children learn them one at a time over the course of several months. This has been shown using a variety of methods including the Give-a-Number task (Wynn, 1990), in which children are asked to give different numbers of objects to an experimenter. Children typically begin by learning the meaning of “one,” and can give one thing when asked, but are unable to reliably give larger numbers. Some time later, children learn the meaning of “two,” and then “three” a few months after that. During this period, children are called “subset-knowers,” because they understand only a subset of the number words in their count list. Also, even though subset-knowers are often very good at reciting the count list, they do not reliably use it to count numbers they know, suggesting that they don’t understand how counting represents number.\nSometime after learning these first few number words, children learn how to use counting to generate large numbers, and no longer need to learn the meanings of number words one by one. At this point, children are called Cardinal Principle (or CP)-knowers, meaning that they understand how the last word said while counting indicates the cardinality of a set (Gelman & Gallistel, 1978)."
  },
  {
    "objectID": "methods.html#number-development",
    "href": "methods.html#number-development",
    "title": "Methods",
    "section": "",
    "text": "While children begin to recite the count list at a very young age (usually by around 2 years; Fuson, 1988), it takes them several years to learn the meanings of the individual words in the count list. For instance, if you ask 2-year-old who can count up to 10 for a set of 3 items, they may give you a random handful. Initially, children can recite a rote count list, like the alphabet. This ability to recite the count list is often measured by the “Highest Count” task.\nInstead of learning the meanings of all these number words at once, children learn them one at a time over the course of several months. This has been shown using a variety of methods including the Give-a-Number task (Wynn, 1990), in which children are asked to give different numbers of objects to an experimenter. Children typically begin by learning the meaning of “one,” and can give one thing when asked, but are unable to reliably give larger numbers. Some time later, children learn the meaning of “two,” and then “three” a few months after that. During this period, children are called “subset-knowers,” because they understand only a subset of the number words in their count list. Also, even though subset-knowers are often very good at reciting the count list, they do not reliably use it to count numbers they know, suggesting that they don’t understand how counting represents number.\nSometime after learning these first few number words, children learn how to use counting to generate large numbers, and no longer need to learn the meanings of number words one by one. At this point, children are called Cardinal Principle (or CP)-knowers, meaning that they understand how the last word said while counting indicates the cardinality of a set (Gelman & Gallistel, 1978)."
  },
  {
    "objectID": "methods.html#about-give-n",
    "href": "methods.html#about-give-n",
    "title": "Methods",
    "section": "About Give-N",
    "text": "About Give-N\nThe Give-a-Number task allows researchers to measure what children know about the meanings of number words and counting. In the task, an experimenter asks the child to generate different numbers of objects. For example, the experimenter might ask children to “Put three bananas on the plate.” To identify the largest number that children comprehend, many different designs have been used. One key distinction is between titrated and non-titrated versions of Give-a-Number (Marchand et al., 2022). In the non-titrated version, the experimenter tests the child on a predetermined set of number words – e.g., the words “one”, “two”, “three”, “four”, “five”, “six”, “eight”, and “ten”. In such versions, it is typical for each number to be assessed three times, with numbers tested in pseudo-random order. By contrast, in the titrated version of the task, the experimenter might begin by testing the child with a particular number word – e.g., “two” and then testing them on a larger number if they succeed, but a smaller number if they fail, on each subsequent trial. In this way, they continue until they find the largest number for which the child provides correct responses on 2/3 trials (sometimes with the additional constraint that on 2/3 of trials that this number of objects, n, is given, it is in response to requests for n objects). For example, a child who can only reliably give sets of 1 and 2 is a “two-knower,” while a child who can generate sets of 5+ is generally classified as a “CP-knower.”\nNumberbank aggregates Give-N data from many labs. It represents the knower levels that children have attained at different ages and in different languages. Also, it represents how they respond to individual trials during the task – e.g., how many objects they give when asked for “three”. Children are classified into the following knower levels:\n\nNon-Knowers: Children who don’t know the meanings of any number words\nOne-Knowers: Children who have an exact label for sets of up to one\nTwo-Knowers: Children who have an exact label for sets of up to two\nThree-Knowers: Children who have an exact label for sets of up to three\nFour-Knowers: Children who have an exact label for sets of up to four\nFive-Knowers: Children who have an exact label for sets of up to five\nCardinal Principle Knowers: Children who can reliably count and give sets larger than 4 or 5 (depending on how this is defined in a particular study)\n\nNumberbank reports knower levels that were assigned to children by the researchers, acknowledging that the methods used to assign knower levels may vary across different labs. However, raw data can be downloaded, allowing researchers to reclassify children according to different criteria. Future versions of Numberbank may also allow researchers to decide upon different classification criteria, where trial-by-trial data make this possible (sometimes researchers have only provided the final knower level, without trial data)."
  },
  {
    "objectID": "methods.html#about-highest-count",
    "href": "methods.html#about-highest-count",
    "title": "Methods",
    "section": "About Highest Count",
    "text": "About Highest Count\nIn the Highest Count task, children’s ability to recite the count list is tested by asking them to count as high as they can. Sometimes researchers record the child’s initial highest count – the point they reach before they make their first error or omission. Sometimes they also record their final highest count – the number they reach after recovering from an error, or after a protocol of prompts (depending on the methods of a particular study).\nNumberbank represents children’s highest counts and by default displays only initial counts as reported by researchers."
  },
  {
    "objectID": "methods.html#references",
    "href": "methods.html#references",
    "title": "Methods",
    "section": "References",
    "text": "References\nFuson, K. C. (1988). Children’s counting and concepts of number. New York: Springer-Verlag.\nGelman, R. and Gallistel, C. R.: 1978, The Child’s Understanding of Number, Harvard University Press, Cambridge.\nWynn, K. (1990). Children’s understanding of counting. Cognition, 36(2), 155-193."
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "Numberbank",
    "section": "",
    "text": "Plot = import(\"https://esm.sh/@observablehq/plot@0.6.13\")\nimport {interval} from '@mootari/range-slider' // two ended slider\n\nfontFamily = \"Source Sans Pro\"\nfontSize = \".7rem\"\nage_label = \"Age (months)\"\nfilter_error = '&lt;p class=\"filter-error\"&gt;&lt;i class=\"bi bi-exclamation-triangle\"&gt;&lt;/i&gt; No data found for selected filters&lt;/p&gt;'\n\nkl = transpose(kl_data)\ntr = transpose(trial_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFacet by…\n\n// facets\nviewof fs = Inputs.checkbox([\"language\", \"country\", \"method\"],\n                            {value: [\"language\"]})\n\n\n\n\n\n\n\nfx = fs.includes(\"method\") ? \"method\" : null // fx = \"method\" or null\nfy = fs.filter(x =&gt; x !== \"method\").join(\"_\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFilter by…\n\nviewof ages = interval([d3.min(kl_data.age), d3.max(kl_data.age)],\n                       {step: 1, label: \"Age (months)\"})\n\n// kl filter\ncp_sort = (a, b) =&gt; a === \"CP-knower\" ? 1 : b === \"CP-knower\" ? -1 : a.localeCompare(b);\nkl_vals = Array.from(new Set(kl_data.kl)).sort(cp_sort) // options\nkl_defs = kl_vals.filter(s =&gt; /^[123C]/.test(s)) // default\nviewof kls = Inputs.select(kl_vals, {label: \"Knower levels\", multiple: true, value: kl_defs})\n\n// kl subset toggle\nviewof kl_sub = Inputs.checkbox([\"Group non-CP-knowers together\"])\nkl_y = kl_sub.length ? \"kl_subset\" : \"kl\"\n\n// language filter\nlang_vals = Array.from(new Set(kl_data.language_countries)).sort() // options\nlang_defs = lang_vals.filter(s =&gt; /English/.test(s))\nviewof langs = Inputs.select(lang_vals, {label: \"Languages\", multiple: true, value: lang_defs})\n\n// country filter\ncountry_vals = Array.from(new Set(kl_data.country_languages)).sort() // options\ncountry_defs = country_vals.filter(s =&gt; /English/.test(s))\nviewof countries = Inputs.select(country_vals, {label: \"Countries\", multiple: true, value: country_defs})\n\n// dataset filter\ndataset_vals = Array.from(new Set(kl_data.dataset_id)).sort() // options\ndataset_defs = dataset_vals // default\nviewof datasets = Inputs.select(dataset_vals, {label: \"Datasets\", multiple: true, value: dataset_defs})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nklf = kl.filter(d =&gt; langs.includes(d.language_countries))\n        .filter(d =&gt; countries.includes(d.country_languages))\n        .filter(d =&gt; datasets.includes(d.dataset_id))\n        .filter(d =&gt; kls.includes(d.kl))\n        .filter(d =&gt; d.age &gt;= ages[0] && d.age &lt;= ages[1])\n\n// possible kl values in filtered data\nklfv = Array.from(new Set(klf.map(d =&gt; d[kl_y]))).sort(cp_sort)\n\nkl_found = klf.length &gt; 0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGive-NHighest count\n\n\n\nPlots – Knower levelsData – Knower levelsPlots – ItemsData – Items\n\n\n\nDisclaimer text goes here\n\n\nhtml`${kl_found ? '' : filter_error}`\n\n\n\n\n\n\n\nss_margin = 180\nkl_found ? Plot.plot({\n  title: \"Counts of knower level in each dataset\",\n  style: { fontFamily: fontFamily, fontSize: fontSize },\n  marginLeft: ss_margin,\n  color: { legend: true, domain: klfv, marginLeft: ss_margin},\n  x: { label: \"\", labelAnchor: \"center\", labelArrow: \"none\", axis: \"top\" },\n  y: { label: \"Dataset\", labelAnchor: \"top\", tickSize: 0, tickPadding: 2 },\n  marks: [\n    Plot.barX(klf, Plot.groupY(\n      { x: \"count\" },\n      { fill: kl_y, y: \"dataset_id\", inset: 1, sort: { y: \"x\", reverse: true, } }\n    )),\n    Plot.textX(klf, Plot.stackX(Plot.groupY(\n      { x: \"count\", text: \"count\" },\n      { y: \"dataset_id\", z: kl_y, fill: \"white\" }\n    ))),\n  ]\n}) : html``\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// boxplot\nkl_found ? Plot.plot({\n  title: \"Distribution of knower level over age\",\n  style: { fontFamily: fontFamily, fontSize: fontSize },\n  marginLeft: 60,\n  marginRight: 100,\n  x: { label: age_label, grid: true, inset: 10, line: true, labelAnchor: \"center\", labelArrow: \"none\" },\n  y: { label: \"Knower level\", labelAnchor: \"top\", tickSize: 0, tickPadding: 2, domain: klfv },\n  color: { domain: klfv },\n  facet: { label: null },\n  marks: [\n    Plot.boxX(klf, {\n      x: \"age\",\n      y: kl_y,\n      fx: fx,\n      fy: fy,\n      fill: kl_y\n    })\n  ]\n}) : html``\n\n\n\n\n\n\n\n// cumulative probability plot\nkl_found ? Plot.plot({\n  title: \"Cumulative probability of knower level over age\",\n  style: { fontFamily: fontFamily, fontSize: fontSize },\n  marginRight: 100,\n  color: { legend: true, domain: klfv },\n  x: { label: age_label, grid: true, inset: 10, line: true, labelAnchor: \"center\", labelArrow: \"none\" },\n  y: { label: \"Cumulative probability of knower level\", inset: 5, line: true, labelAnchor: \"center\", labelArrow: \"none\" },\n  facet: { label: null },\n  marks: [\n    Plot.lineY(klf, Plot.normalizeY(\"extent\", // scale to 0-1\n                    Plot.mapY(\"cumsum\", // cumulative sum\n                    Plot.binY({ y: \"count\" }, { // count in each age bin\n      x: \"age\",\n      stroke: kl_y,\n      fx: fx,\n      fy: fy\n    }))))\n  ]\n}) : html``\n\n\n\n\n\n\n\n\n\n\n\n\n\nDisclaimer text goes here\n\n\ntrf = tr.filter(d =&gt; langs.includes(d.language_countries))\n        .filter(d =&gt; countries.includes(d.country_languages))\n        .filter(d =&gt; datasets.includes(d.dataset_id))\n        .filter(d =&gt; kls.includes(d.kl))\n        .filter(d =&gt; d.age &gt;= ages[0] && d.age &lt;= ages[1])\n\ntr_found = trf.length &gt; 0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhtml`${tr_found ? '' : filter_error}`\n\n\n\n\n\n\n\nrc_map = d3.rollup(trf, v =&gt; v.length, d =&gt; d[kl_y], d =&gt; d.query, d =&gt; d.response)\n\nrc = Array.from(rc_map, ([kl, kl_responses]) =&gt;\n  Array.from(kl_responses, ([query, query_responses]) =&gt; \n    Array.from(query_responses, ([response, count]) =&gt;\n      ({ kl, query, response, count, total: d3.sum(query_responses.values())})\n    ).map(d =&gt; ({ ...d, proportion: d.count / d.total }))\n  ).flat()\n).flat()\n\ntr_found ? Plot.plot({\n  title: \"Distribution of responses by knower level\",\n  style: { fontFamily: fontFamily, fontSize: fontSize },\n  width: 950,\n  height: 120 * rc_map.size,\n  marginRight: 100,\n  x: { label: \"Response\" },\n  y: { label: \"Proportion responses\", grid: true, domain: [0, 1] },\n  fx: { label: \"Query\" },\n  fy: { label: null, padding: 0.2, domain: klfv },\n  color: { domain: klfv },\n  marks: [\n    Plot.rectY(rc, {\n      x: \"response\",\n      y: \"proportion\",\n      fx: \"query\",\n      fy: \"kl\",\n      fill: \"kl\",\n      padding: 0.03\n    }),\n    Plot.axisX({ facetAnchor: null }),\n    Plot.axisY({ facetAnchor: \"left\", labelAnchor: \"center\", labelArrow: \"none\" }),\n    Plot.ruleY([0])\n  ]\n}) : html``\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlotsData\n\n\n\nDisclaimer text goes here\n\n\nhcf = klf.filter(s =&gt; s.hc)\nhc_found = hcf.length &gt; 0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhtml`${hc_found ? '' : filter_error}`\n\n\n\n\n\n\n\n// sample size plot\nhc_found ? Plot.plot({\n  title: \"Counts in each dataset\",\n  style: { fontFamily: fontFamily, fontSize: fontSize },\n  marginLeft: ss_margin,\n  x: { label: \"\", labelAnchor: \"center\", labelArrow: \"none\", axis: \"top\" },\n  y: { label: \"Dataset\", labelAnchor: \"top\", tickSize: 0, tickPadding: 2 },\n  //x: { axis: \"top\", label: \"Count\" },\n  //y: { label: \"Dataset\" },\n  marks: [\n    Plot.barX(hcf, Plot.groupY(\n      { x: \"count\" },\n      { y: \"dataset_id\", inset: 1, sort: { y: \"x\", reverse: true, } } //order: \"sum\"\n    )),\n    Plot.textX(hcf, Plot.stackX(Plot.groupY(\n      { x: \"count\", text: \"count\" },\n      { y: \"dataset_id\", fill: \"white\", } //order: \"sum\" }\n    ))),\n  ]\n}) : html``\n\n\n\n\n\n\n\nhc_found ? Plot.plot({\n  title: \"Highest count over age\",\n  style: { fontFamily: fontFamily, fontSize: fontSize },\n  marginRight: 100,\n  //color: { legend: true, domain: klfv },\n  x: { label: age_label, grid: true, inset: 10, line: true, labelAnchor: \"center\", labelArrow: \"none\" },\n  y: { label: \"Highest count\", inset: 5, line: true, labelAnchor: \"center\", labelArrow: \"none\" },\n  //x: { label: age_label, grid: true, inset: 10 },\n  //y: { label: \"Highest count\", inset: 10 },\n  facet: { label: null },\n  marks: [\n    //Plot.frame(),\n    Plot.dot(hcf, {\n      x: \"age\",\n      y: \"hc\",\n      fill: \"black\",\n      fx: fx,\n      fy: fy\n    })\n  ]\n}) : html``\n\n\n\n\n\n\n\nhc_found ? Plot.plot({\n  title: \"Distribution of highest count\",\n  style: { fontFamily: fontFamily, fontSize: fontSize },\n  marginRight: 100,\n  //color: { legend: true, domain: klfv },\n  x: { label: \"Highest count\", grid: true, inset: 10, line: true, labelAnchor: \"center\", labelArrow: \"none\" },\n  y: { line: true, labelAnchor: \"center\", labelArrow: \"none\" },\n  //x: { label: \"Highest count\", grid: true, inset: 10 },\n  //y: { inset: 10 },\n  facet: { label: null },\n  marks: [\n    //Plot.frame(),\n    Plot.rectY(hcf, Plot.binX({y: \"count\"}, {\n      x: \"hc\",\n      fx: fx,\n      fy: fy\n    }))\n  ]\n}) : html``\n\n\n\n\n\n\n\n// boxplot\nhc_found ? Plot.plot({\n  title: \"Distribution of highest count by knower level\",\n  style: { fontFamily: fontFamily, fontSize: fontSize },\n  marginLeft: 60,\n  marginRight: 100,\n  x: { label: \"Highest count\", grid: true, inset: 10, line: true, labelAnchor: \"center\", labelArrow: \"none\" },\n  y: { label: \"Knower level\", labelAnchor: \"top\", tickSize: 0, tickPadding: 2, domain: klfv },\n  //x: { label: \"Highest count\", grid: true, inset: 10 },\n  //y: { label: \"Knower level\", domain: klfv },\n  color: { domain: klfv },\n  facet: { label: null },\n  marks: [\n    Plot.boxX(hcf, {\n      x: \"hc\",\n      y: kl_y,\n      fx: fx,\n      fy: fy,\n      fill: kl_y\n    })\n  ]\n}) : html``"
  },
  {
    "objectID": "md/disclaimer-kl.html",
    "href": "md/disclaimer-kl.html",
    "title": "Numberbank",
    "section": "",
    "text": "Disclaimer text goes here"
  },
  {
    "objectID": "md/disclaimer-hc.html",
    "href": "md/disclaimer-hc.html",
    "title": "Numberbank",
    "section": "",
    "text": "Disclaimer text goes here"
  }
]